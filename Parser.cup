package parser;

import java_cup.runtime.*;
import syntax_tree.*;
import syntax_tree.comp.*;
import syntax_tree.leaf.*;
import syntax_tree.var_init.*;
import syntax_tree.wrapperas.*;

/*List of terminals*/
terminal HEAD;
terminal START;
terminal SEMI;
terminal String BOOL;
terminal String DOUBLE;
terminal String STRING;
terminal String CHAR;
terminal String ID;
terminal COMMA;
terminal DEF;
terminal LPAR;
terminal RPAR;
terminal LGPAR;
terminal RGPAR;
terminal READ;
terminal WRITE;
terminal char PLUS;
terminal char MINUS;
terminal char TIMES;
terminal char DIV;
terminal String INT_CONST;
terminal String DOUBLE_CONST;
terminal String STRING_CONST;
terminal String CHAR_CONST;
terminal TRUE;
terminal FALSE;
terminal ASSIGN;
terminal IF;
terminal THEN;
terminal WHILE;
terminal DO;
terminal ELSE;
terminal GT;
terminal GE;
terminal LT;
terminal LE;
terminal EQ;
terminal NOT;
terminal AND;
terminal OR;
terminal IN;
terminal OUT;
terminal INOUT;
terminal INT;
terminal UMINUS; /*is the Symbol '-'  used for unary operation*/


/*List of non teminals*/  
non terminal	Internal	Programma; 
non terminal	Internal 	Decls;
non terminal	Internal 	Statements; 
non terminal	Internal	Var_decl;
non terminal	String	Type;
non terminal	Internal	Var_decls_init;
non terminal	Node	Var_init_value;
non terminal	Node	Vars;
non terminal	Internal	Def_decl;
non terminal	Internal	Var_decls;
non terminal	Internal	Par_decls;  
non terminal	Leaf	Par_type;
non terminal	Internal	Body;
non terminal	Internal	Stat;
non terminal	Internal	Args;
non terminal	Internal	Comp_stat;
non terminal	Node	Expr;

/*List of precedences*/ 

precedence nonassoc  ELSE; 
precedence left PLUS,MINUS,OR;
precedence left TIMES,DIV,AND;
precedence nonassoc GT, GE, LT, LE, EQ; 
precedence left UMINUS, NOT, COMMA;


/*Grammar*/														
Programma 	::= HEAD Decls:decls START Statements:s 			{: RESULT = new Internal("Program", decls, s);	
																		System.out.println(RESULT.toString());:}
			;
																
Decls 		::= Var_decl:var Decls:decls						{: RESULT = decls.addChild(var); :}
			|	Def_decl:def Decls:decls						{: RESULT = decls.addChild(def); :}
			|	/*epsilon*/										{: RESULT = new Internal("DeclsOp");	:}		
			;
Statements	::=	Stat:s Statements:st							{:	RESULT = st.addChild(s); 	:}
			|	/*epsilon*/										{:	RESULT = new Internal("Statements");	:}
			;
Var_decl	::=	Type:tp Var_decls_init:vdi SEMI 				{: RESULT = new Internal("VarDeclOp", new Leaf("Type", tp), vdi); :}	
			;
Type		::=	INT 											{: RESULT = "Type_Int"; :}
			|	BOOL 											{: RESULT = "Type_Bool"; :}
			|	DOUBLE 											{: RESULT = "Type_Double"; :}
			|	STRING 											{: RESULT = "Type_String"; :}
			|	CHAR 											{: RESULT = "Type_Char"; :}
			;
			
Var_decls_init	::=	ID:id Var_init_value:viv COMMA Var_decls_init:vdi
																{:	Internal tr = (viv == null)
																							?new Internal("VarNotInitOp", new Leaf("ID", id))
																							:new Internal("VarInitOp", new Leaf("ID", id), viv); 
																			RESULT = vdi.addChild(tr); :}
				
				|	ID:id Var_init_value:viv					{:	Internal tr = (viv == null)
																							?new Internal("VarNotInitOp", new Leaf("ID", id))
																							:new Internal("VarInitOp", new Leaf("ID", id), viv); 
																			RESULT = new Internal("VarDeclsInit", tr);	:}
				;
				
Var_init_value	::= ASSIGN Expr:e								{: 	RESULT = e;		:}
				| /*epsilon*/									{:	RESULT = null;	:}
				;
				
Vars		::=	ID:id COMMA Vars:v								{:	RESULT = ((Internal)v).addChild(new Leaf("ID",id)); :}
			|	ID:id											{: 	Leaf l = new Leaf("ID", id);
																	RESULT = new Internal("Vars", l); :}							
			;
			
Def_decl	::=	DEF ID:id LPAR Par_decls:pd RPAR Body:body		{:	RESULT = new Internal("DefDeclwithPar", new Leaf("ID", id), body, pd); :}
			|	DEF ID:id LPAR RPAR Body:body					{:	RESULT = new Internal("DefDeclOp", new Leaf("ID", id), body);	:}
			;
			
Var_decls	::=	Var_decl:vs Var_decls:vp						{:	RESULT = vp.addChild(vs); :}														
			| 	/*epsilon*/										{:	RESULT = new Internal("VarDeclsOp");	:}
			;
			
Par_decls	::=	Par_type:part Type:type ID:id COMMA Par_decls:pard	
																{:	RESULT  = pard.addChild(new Internal("Par", part, new Leaf("Type", type), new Leaf("ID", id))); :}
			|	Par_type:p Type:type ID:id						{: 	Internal par = new Internal("Par", p, new Leaf("Type", type), new Leaf("ID", id));
																	RESULT = new Internal("Par_decls", par);	:}
			;
			
Par_type	::=	IN												{: RESULT = new Leaf("IN", "in"); :}
			|	OUT												{: RESULT = new Leaf("OUT", "out"); :}
			|	INOUT											{: RESULT = new Leaf("INOUT", "inout"); :}
			;
			
Body		::=	LGPAR Var_decls:vds Statements:s RGPAR			{: 	RESULT = new Internal("Body", vds, s); :}
			;
Stat		::= Vars:vars READ SEMI								{:	RESULT = new Internal("ReadOp", vars); :}
			|	Args:args WRITE SEMI							{:	RESULT = new Internal("WriteOp", args); :}
			|	ID:id ASSIGN Expr:e1 SEMI 						{: 	RESULT = new Internal("AssignOp", new Leaf("ID",id), e1); :}		
			|	ID:id LPAR Args:args RPAR SEMI					{:	RESULT = new Internal("CallOp", new Leaf("ID", id), args); :}
			|	ID:id LPAR RPAR SEMI							{: 	RESULT = new Internal("CallOp", new Leaf("ID", id)); :}
			|	IF LPAR Expr:e RPAR THEN Comp_stat:c1 ELSE Comp_stat:c2 
																{: RESULT = new Internal("IfThenElseOp", e, c1, c2); :}
																
			|	IF LPAR Expr:e RPAR THEN Comp_stat:c			{: RESULT = new Internal("IfThenOp", e, c); :}					
			|	WHILE LPAR Expr:e RPAR DO Comp_stat:c			{: RESULT = new Internal("While", e, c); :}
			; 
			
Args		::=	Expr:e1 COMMA Args:e2							{: RESULT = e2.addChild(e1); :}
			|	Expr:e											{: RESULT = new Internal("Args", e); :}
			;
			
Comp_stat	::=	LGPAR Statements:s RGPAR						{: RESULT = s; :}
			;
  
Expr		::= Expr:e1 MINUS Expr:e2							{:	RESULT = new Internal("SubOp",	e1, e2); :}
			|	Expr:e1 PLUS Expr:e2							{:	RESULT = new Internal("AddOp",	e1, e2); :}			
			| 	Expr:e1 TIMES Expr:e2							{:	RESULT = new Internal("MulOp",	e1, e2); :}			
			|	Expr:e1 DIV Expr:e2								{: 	RESULT = new Internal("DivOp",	e1, e2); :}																
			|	Expr:e1 AND Expr:e2								{:  RESULT = new Internal("AndOp",	e1, e2); :}			
			|	Expr:e1 OR Expr:e2								{:  RESULT = new Internal("OrOp",	e1, e2); :}																
			|	Expr:e1 GT Expr:e2								{:	RESULT = new Internal("GtOp", e1, e2);	:}			
			|	Expr:e1 LT Expr:e2								{:	RESULT = new Internal("LtOp", e1, e2);	:}
			|	Expr:e1 GE Expr:e2								{:	RESULT = new Internal("GeOp", e1, e2);	:}
			|	Expr:e1 LE Expr:e2								{:	RESULT = new Internal("LeOp", e1, e2);	:}
			|	Expr:e1 EQ Expr:e2								{:	RESULT = new Internal("EqOp", e1, e2);	:}				
			|	MINUS Expr:e1 									{: RESULT = new Internal("Uminus", e1); :} %prec UMINUS		
			|	NOT Expr:e										{: RESULT = new Internal("NotOp", e); :}
			|	LPAR Expr:e RPAR								{: RESULT = e; :}
			|	TRUE											{: RESULT = new Leaf("TRUE","true"); :}
			|	FALSE											{: RESULT = new Leaf("FALSE","false"); :}
			|	ID:id											{: RESULT = new Leaf("ID", id); :}
			|	INT_CONST:intConst 								{: RESULT = new Leaf("INT_CONST", intConst); :}
			|	DOUBLE_CONST:doubleConst						{: RESULT = new Leaf("DOUBLE_CONST", doubleConst); :}
			|	CHAR_CONST:charConst							{: RESULT = new Leaf("CHAR_CONST", charConst); :}
			|	STRING_CONST:stringConst 						{: RESULT = new Leaf("STRING_CONST", stringConst); :}
			;													
